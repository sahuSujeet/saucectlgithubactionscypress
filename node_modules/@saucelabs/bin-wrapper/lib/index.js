"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinWrapper = void 0;
const path_1 = __importDefault(require("path"));
const promises_1 = __importDefault(require("fs/promises"));
const download_1 = require("./download");
const run_1 = require("./run");
class BinWrapper {
    options = {};
    sources = [];
    binPath = path_1.default.join(__dirname, 'bin');
    binName = 'bin';
    src(path, os, arch) {
        this.sources.push({ os: os, arch: arch, path: path });
        return this;
    }
    dest(path) {
        this.binPath = path;
        return this;
    }
    use(name) {
        this.binName = name;
        return this;
    }
    httpOptions(options) {
        this.options = options;
        return this;
    }
    async install() {
        if (await this.isBinPresent()) {
            return;
        }
        const downloadUrl = this.findMatchingPlatform();
        await (0, download_1.downloadAndUnpack)(downloadUrl.path, this.binName, path_1.default.join(this.binPath, this.binName), this.options);
    }
    async run(args, stdio) {
        await this.install();
        return await (0, run_1.run)(path_1.default.join(this.binPath, this.binName), args, stdio);
    }
    async isBinPresent() {
        let st;
        try {
            st = await promises_1.default.stat(this.path());
        }
        catch (e) {
            return false;
        }
        if (!st.isFile()) {
            throw new Error(`${this.path()} exists but is not a file`);
        }
        return true;
    }
    findMatchingPlatform() {
        const matches = this.sources.filter((x) => x.arch === process.arch && x.os === process.platform);
        if (matches.length == 0) {
            throw new Error(`no package found for ${process.platform}_${process.arch}`);
        }
        return matches[0];
    }
    path() {
        return path_1.default.join(this.binPath, this.binName);
    }
}
exports.BinWrapper = BinWrapper;
