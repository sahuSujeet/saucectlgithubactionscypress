"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.download = exports.downloadAndUnpack = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const axios_1 = __importDefault(require("axios"));
const path_1 = __importDefault(require("path"));
const gzip_1 = __importDefault(require("./archive/gzip"));
const zip_1 = __importDefault(require("./archive/zip"));
const tar_1 = __importDefault(require("./archive/tar"));
const https_proxy_agent_1 = require("https-proxy-agent");
async function downloadAndUnpack(url, filepath, binary, options = {}) {
    const payload = await download(url, options);
    const files = await extract(payload);
    const found = files.filter((x) => x.path == filepath);
    if (found.length < 1) {
        throw new Error(`unable to find ${filepath} in ${sanitizeURL(url)}`);
    }
    return await save(found[0], binary);
}
exports.downloadAndUnpack = downloadAndUnpack;
function getHttpsProxyValue() {
    for (const k of Object.keys(process.env)) {
        if (k.toUpperCase() === 'HTTPS_PROXY') {
            return process.env[k];
        }
    }
    return undefined;
}
async function download(url, options) {
    const opts = {
        headers: options.headers,
        responseType: 'arraybuffer',
    };
    const httpsProxy = getHttpsProxyValue();
    if (httpsProxy && url.toString().startsWith('https:')) {
        opts.httpsAgent = new https_proxy_agent_1.HttpsProxyAgent(httpsProxy);
        // Disable axios native proxy. Let HttpsProxyAgent handle it.
        opts.proxy = false;
    }
    return await axios_1.default
        .get(url.toString(), opts)
        .then((res) => {
        return res.data;
    })
        .catch((err) => {
        if (err.response) {
            throw new Error(`failed to download from ${sanitizeURL(url)} (${err.response.status}): ${err.response.data}`);
        }
        throw new Error(`failed to download: ${err}`);
    });
}
exports.download = download;
async function extract(buf) {
    if (gzip_1.default.isGzip(buf)) {
        buf = await gzip_1.default.gunzip(buf);
    }
    const unarchiveMapping = [
        { detector: tar_1.default.isTar, unarchive: tar_1.default.unpackTar },
        { detector: zip_1.default.isZip, unarchive: zip_1.default.unpackZip },
    ];
    for (const it of unarchiveMapping) {
        if (it.detector(buf)) {
            return await it.unarchive(buf);
        }
    }
    throw new Error(`unrecognized archive kind`);
}
async function save(file, install) {
    const baseDir = path_1.default.dirname(install);
    await promises_1.default.mkdir(baseDir, { recursive: true });
    await promises_1.default.writeFile(install, file.data);
    await promises_1.default.chmod(install, 0o755);
}
/**
 * Sanitize URL for logging by redacting credentials, if present.
 */
function sanitizeURL(dirtyURL) {
    const url = new URL(dirtyURL.toString());
    if (url.username || url.password) {
        url.username = '***';
        url.password = '***';
    }
    return url.toString();
}
